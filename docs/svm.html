<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>데이터마이닝 with R</title>
  <meta name="description" content="전치혁 교수님의 책 <데이터마이닝 기법과 응용>을 기반으로 한 R 예제">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="데이터마이닝 with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://youngroklee-ml.github.io/data-mining-book/" />
  
  <meta property="og:description" content="전치혁 교수님의 책 <데이터마이닝 기법과 응용>을 기반으로 한 R 예제" />
  <meta name="github-repo" content="youngroklee-ml/data-mining-book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="데이터마이닝 with R" />
  
  <meta name="twitter:description" content="전치혁 교수님의 책 <데이터마이닝 기법과 응용>을 기반으로 한 R 예제" />
  

<meta name="author" content="전치혁, 이혜선, 이종석, 이영록">


<meta name="date" content="2018-09-09">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="tree-based-method.html">
<link rel="next" href="references.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">데이터마이닝 with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>개요</a></li>
<li class="chapter" data-level="1" data-path="tree-based-method.html"><a href="tree-based-method.html"><i class="fa fa-check"></i><b>1</b> 트리기반 기법</a><ul>
<li class="chapter" data-level="1.1" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-overview"><i class="fa fa-check"></i><b>1.1</b> CART 개요</a></li>
<li class="chapter" data-level="1.2" data-path="tree-based-method.html"><a href="tree-based-method.html#-r-package-"><i class="fa fa-check"></i><b>1.2</b> 필요 R package 설치</a></li>
<li class="chapter" data-level="1.3" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-build"><i class="fa fa-check"></i><b>1.3</b> CART 트리 생성</a><ul>
<li class="chapter" data-level="1.3.1" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-basic-r-script"><i class="fa fa-check"></i><b>1.3.1</b> 기본 R 스크립트</a></li>
<li class="chapter" data-level="1.3.2" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-notation"><i class="fa fa-check"></i><b>1.3.2</b> 기호 정의</a></li>
<li class="chapter" data-level="1.3.3" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-impurity"><i class="fa fa-check"></i><b>1.3.3</b> 노드 및 트리의 불순도</a></li>
<li class="chapter" data-level="1.3.4" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-split"><i class="fa fa-check"></i><b>1.3.4</b> 분지기준</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-pruning-complete"><i class="fa fa-check"></i><b>1.4</b> 가지치기 및 최종 트리 선정</a><ul>
<li class="chapter" data-level="1.4.1" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-pruning"><i class="fa fa-check"></i><b>1.4.1</b> 가지치기</a></li>
<li class="chapter" data-level="1.4.2" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-best-tree"><i class="fa fa-check"></i><b>1.4.2</b> 최적 트리의 선정</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-r-pkg"><i class="fa fa-check"></i><b>1.5</b> R패키지 내 분류 트리 방법</a><ul>
<li class="chapter" data-level="1.5.1" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-r-pkg-split"><i class="fa fa-check"></i><b>1.5.1</b> 트리 확장</a></li>
<li class="chapter" data-level="1.5.2" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-r-pkg-pruning"><i class="fa fa-check"></i><b>1.5.2</b> 가지치기</a></li>
<li class="chapter" data-level="1.5.3" data-path="tree-based-method.html"><a href="tree-based-method.html#cart-r-pkg-param"><i class="fa fa-check"></i><b>1.5.3</b> 파라미터값 결정</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="svm.html"><a href="svm.html"><i class="fa fa-check"></i><b>2</b> 서포트 벡터 머신</a><ul>
<li class="chapter" data-level="2.1" data-path="svm.html"><a href="svm.html#svm-overview"><i class="fa fa-check"></i><b>2.1</b> 개요</a></li>
<li class="chapter" data-level="2.2" data-path="svm.html"><a href="svm.html#-r-package--1"><i class="fa fa-check"></i><b>2.2</b> 필요 R package 설치</a></li>
<li class="chapter" data-level="2.3" data-path="svm.html"><a href="svm.html#linear-svm-separable"><i class="fa fa-check"></i><b>2.3</b> 선형 SVM - 분리 가능 경우</a><ul>
<li class="chapter" data-level="2.3.1" data-path="svm.html"><a href="svm.html#linear-svm-separable-basic-script"><i class="fa fa-check"></i><b>2.3.1</b> 기본 R 스크립트</a></li>
<li class="chapter" data-level="2.3.2" data-path="svm.html"><a href="svm.html#linear-svm-notation"><i class="fa fa-check"></i><b>2.3.2</b> 기호 정의</a></li>
<li class="chapter" data-level="2.3.3" data-path="svm.html"><a href="svm.html#linear-svm-separable-hyperplane"><i class="fa fa-check"></i><b>2.3.3</b> 최적 하이퍼플레인</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">데이터마이닝 with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="svm" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> 서포트 벡터 머신</h1>
<div id="svm-overview" class="section level2">
<h2><span class="header-section-number">2.1</span> 개요</h2>
<p>서포트 벡터 머신(suuport vector machine; 이하 SVM)은 기본적으로 두 범주를 갖는 객체들을 분류하는 방법이다. 물론 세 범주 이상의 경우로 확장이 가능하다.</p>
</div>
<div id="-r-package--1" class="section level2">
<h2><span class="header-section-number">2.2</span> 필요 R package 설치</h2>
<p>본 장에서 필요한 R 패키지들은 아래와 같다.</p>
<table>
<thead>
<tr class="header">
<th align="left">package</th>
<th align="left">version</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">tidyverse</td>
<td align="left">1.2.1</td>
</tr>
<tr class="even">
<td align="left">e1071</td>
<td align="left">1.6-8</td>
</tr>
<tr class="odd">
<td align="left">Matrix</td>
<td align="left">1.2-14</td>
</tr>
<tr class="even">
<td align="left">quadprog</td>
<td align="left">1.5-5</td>
</tr>
</tbody>
</table>
</div>
<div id="linear-svm-separable" class="section level2">
<h2><span class="header-section-number">2.3</span> 선형 SVM - 분리 가능 경우</h2>
<div id="linear-svm-separable-basic-script" class="section level3">
<h3><span class="header-section-number">2.3.1</span> 기본 R 스크립트</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">train_df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x1 =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">9</span>, <span class="dv">5</span>),
  <span class="dt">x2 =</span> <span class="kw">c</span>(<span class="dv">7</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">4</span>),
  <span class="dt">class =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)
)

knitr<span class="op">::</span><span class="kw">kable</span>(train_df, <span class="dt">booktabs =</span> <span class="ot">TRUE</span>,
             <span class="dt">align =</span> <span class="kw">c</span>(<span class="st">&#39;r&#39;</span>, <span class="st">&#39;r&#39;</span>, <span class="st">&#39;r&#39;</span>),
             <span class="dt">caption =</span> <span class="st">&#39;학습표본 데이터&#39;</span>)</code></pre></div>
<table>
<caption><span id="tab:svm-train-data-table">Table 2.1: </span>학습표본 데이터</caption>
<thead>
<tr class="header">
<th align="right">x1</th>
<th align="right">x2</th>
<th align="right">class</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">5</td>
<td align="right">7</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">3</td>
<td align="right">-1</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="right">8</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">6</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">6</td>
<td align="right">-1</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">5</td>
<td align="right">-1</td>
</tr>
<tr class="odd">
<td align="right">6</td>
<td align="right">6</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">9</td>
<td align="right">6</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">4</td>
<td align="right">-1</td>
</tr>
</tbody>
</table>
<p>Table <a href="svm.html#tab:svm-train-data-table">2.1</a>와 같이 두 독립변수 <em>x1</em>, <em>x2</em>와 이분형 종속변수 <em>class</em>의 관측값으로 이루어진 9개의 학습표본을 <em>train_df</em>라는 data frame에 저장한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(e1071)
svm_model &lt;-<span class="st"> </span><span class="kw">svm</span>(<span class="kw">as.factor</span>(class) <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2, <span class="dt">data =</span> train_df, <span class="dt">kernel =</span> <span class="st">&quot;linear&quot;</span>,
                 <span class="dt">cost =</span> <span class="dv">100</span>, <span class="dt">scale =</span> <span class="ot">FALSE</span>)
<span class="kw">plot</span>(svm_model, <span class="dt">data =</span> train_df, <span class="dt">formula =</span> x2 <span class="op">~</span><span class="st"> </span>x1, <span class="dt">grid =</span> <span class="dv">200</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:linear-svm-basic"></span>
<img src="data-mining-book_files/figure-html/linear-svm-basic-1.png" alt="선형 SVM 분리 하이퍼플레인" width="672" />
<p class="caption">
Figure 2.1: 선형 SVM 분리 하이퍼플레인
</p>
</div>
<p>그림 <a href="svm.html#fig:linear-svm-basic">2.1</a>에서 분리 하이퍼플레인은 아래와 같다.</p>
<p><span class="math display">\[
0.6666667 x_{1} + 0.6666667 x_{2} = 7
\]</span></p>
</div>
<div id="linear-svm-notation" class="section level3">
<h3><span class="header-section-number">2.3.2</span> 기호 정의</h3>
<p>본 장에서 사용될 수학적 기호는 아래와 같다.</p>
<ul>
<li><span class="math inline">\(\mathbf{x} \in \mathbb{R}^p\)</span>: p차원 변수벡터</li>
<li><span class="math inline">\(y \in \{-1, 1\}\)</span>: 범주</li>
<li><span class="math inline">\(N\)</span>: 객체 수</li>
<li><span class="math inline">\((\mathbf{x}_i, y_i)\)</span>: <span class="math inline">\(i\)</span>번째 객체의 변수벡터와 범주값</li>
</ul>
</div>
<div id="linear-svm-separable-hyperplane" class="section level3">
<h3><span class="header-section-number">2.3.3</span> 최적 하이퍼플레인</h3>
<p>선형 SVM은 주어진 객체들의 두 범주를 완벽하게 분리하는 하이퍼플레인 중 각 범주의 서포트 벡터들로부터의 거리가 최대가 되는 하이퍼플레인을 찾는 문제로 귀착된다.</p>
<p>우선 아래와 같이 하이퍼플레인을 정의한다.</p>
<span class="math display" id="eq:linear-svm-hyperplane">\[\begin{equation}
\mathbf{w}^\top \mathbf{x} + b = 0 \tag{2.1}
\end{equation}\]</span>
<p>여기서 <span class="math inline">\(\mathbf{w} \in \mathbb{R}^p\)</span>와 <span class="math inline">\(b \in \mathbb{R}\)</span>이 하이퍼플레인의 계수이다.</p>
<p>범주값이 1인 객체들 중 하이퍼플레인에서 가장 가까운 객체에 대해 다음과 같은 조건이 만족한다고 가정하자.</p>
<p><span class="math display">\[
H_1: \mathbf{w}^\top \mathbf{x} + b = 1 
\]</span></p>
<p>또한 범주값이 -1인 객체들 중 하이퍼플레인에서 가장 가까운 객체에 대해 다음과 같은 조건이 만족한다고 가정하자.</p>
<p><span class="math display">\[
H_2: \mathbf{w}^\top \mathbf{x} + b = -1
\]</span></p>
<p>이 때 두 하이퍼플레인 <span class="math inline">\(H_1\)</span>과 <span class="math inline">\(H_2\)</span> 간의 거리(margin)는 <span class="math inline">\(2 / \lVert \mathbf{w} \rVert\)</span>이다. 선형 SVM은 아래와 같이 <span class="math inline">\(H_1\)</span>과 <span class="math inline">\(H_2\)</span> 간의 거리를 최대로 하는 최적화 문제가 된다.</p>
<span class="math display">\[\begin{equation*}
\begin{split}
\max \text{  } &amp; \frac{2}{\mathbf{w}^\top \mathbf{w}}\\
\text{s.t.}&amp; \\
&amp; \mathbf{w}^\top \mathbf{x}_i + b \ge 1 \text{ for } y_i = 1\\
&amp; \mathbf{w}^\top \mathbf{x}_i + b \le -1 \text{ for } y_i = -1
\end{split}
\end{equation*}\]</span>
<p>이를 간략히 정리하면</p>
<span class="math display">\[\begin{equation*}
\begin{split}
\min \text{  } &amp; \frac{\mathbf{w}^\top \mathbf{w}}{2}\\
\text{s.t.}&amp; \\
&amp; y_i \left( \mathbf{w}^\top \mathbf{x}_i + b \right) \ge 1
\end{split}
\end{equation*}\]</span>
<p>과 같이 정리할 수 있으며, 각 객체 <span class="math inline">\(i\)</span>에 대한 제약조건에 라그랑지 계수(Lagrange multiplier) <span class="math inline">\(\alpha_i \ge 0\)</span>를 도입하여 라그랑지 함수를 유도하면 식 <a href="svm.html#eq:linear-svm-primal">(2.2)</a>과 같은 최적화 문제가 된다. 이를 원문제(primal problem)라 하자.</p>
<span class="math display" id="eq:linear-svm-primal">\[\begin{equation}
\begin{split}
\min \text{  } &amp; L_p = \frac{1}{2} \mathbf{w}^\top \mathbf{w} + \sum_{i = 1}^{N} \alpha_i \left[ y_i \left( \mathbf{w}^\top \mathbf{x}_i + b \right) - 1 \right]\\
\text{s.t.  } &amp; \alpha_i \ge 0, \text{  } i = 1, \cdots, N
\end{split}
\tag{2.2}
\end{equation}\]</span>
<p>원문제 식 <a href="svm.html#eq:linear-svm-primal">(2.2)</a>에 대한 울프쌍대문제(Wolfe dual problem)는 아래 식 <a href="svm.html#eq:linear-svm-dual">(2.3)</a>과 같이 도출된다. 보다 자세한 내용은 교재<span class="citation">(전치혁 <a href="#ref-jun2012datamining">2012</a>)</span> 참고.</p>
<span class="math display" id="eq:linear-svm-dual">\[\begin{equation}
\begin{split}
\max \text{  } &amp; L_p = \sum_{i = 1}^{N} \alpha_i - \frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \mathbf{x}_i^\top \mathbf{x}_j\\
\text{s.t. } &amp;\\
&amp; \sum_{i = 1}^{N} \alpha_i y_i = 0\\
&amp; \alpha_i \ge 0, \text{  } i = 1, \cdots, N
\end{split}
\tag{2.3}
\end{equation}\]</span>
<p>식 <a href="svm.html#eq:linear-svm-dual">(2.3)</a>은 이차계획(quadratic programming) 문제로, 각종 소프트웨어와 알고리즘을 이용하여 구할 수 있다. 본 장에서는 <code>quadprog</code> 패키지를 이용하여 해를 구하기로 한다. 이는 실제로 <code>e1071</code>의 <code>svm</code> 함수 호출 시 사용하는 방법은 아니며, 실제 <code>svm</code> 함수가 호출하는 알고리즘은 다음 장에서 다시 설명하기로 한다.</p>
<p><code>quadprog</code>의 <code>solve.QP</code> 함수는 아래와 같은 형태로 formulation된 문제<span class="citation">(Goldfarb and Idnani <a href="#ref-goldfarb1983numerically">1983</a>)</span>에 대한 최적해를 구한다.</p>
<span class="math display" id="eq:quadprog">\[\begin{equation}
\begin{split}
\min \text{  } &amp; -\mathbf{d}^{\top}\boldsymbol{\alpha} + \frac{1}{2} \boldsymbol{\alpha}^{\top}\mathbf{D}\boldsymbol{\alpha}\\
\text{s.t. } &amp; \mathbf{A}^{\top}\boldsymbol{\alpha} \ge \mathbf{b}_0
\end{split}
\tag{2.4}
\end{equation}\]</span>
<p>식 <a href="svm.html#eq:quadprog">(2.4)</a>과 식 <a href="svm.html#eq:linear-svm-dual">(2.3)</a>이 동일한 문제를 나타내도록 아래와 같이 목적함수에 필요한 벡터 및 행렬을 정의한다.</p>
<span class="math display">\[\begin{eqnarray*}
\mathbf{d} &amp;=&amp; \mathbf{1}_{N \times 1}\\
\mathbf{D} &amp;=&amp; \mathbf{y}\mathbf{y}^{\top}\mathbf{X}\mathbf{X}^{\top}
\end{eqnarray*}\]</span>
where
<span class="math display">\[\begin{eqnarray*}
\mathbf{y} &amp;=&amp; \left[ \begin{array}{c c c c} y_1 &amp; y_2 &amp; \cdots &amp; y_N \end{array} \right]^\top\\
\mathbf{X} &amp;=&amp; \left[ \begin{array}{c c c c} \mathbf{x}_1 &amp; \mathbf{x}_2 &amp; \cdots &amp; \mathbf{x}_N \end{array} \right]^{\top}
\end{eqnarray*}\]</span>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">N &lt;-<span class="st"> </span><span class="kw">dim</span>(train_df)[<span class="dv">1</span>]
X &lt;-<span class="st"> </span>train_df[<span class="kw">c</span>(<span class="st">&#39;x1&#39;</span>, <span class="st">&#39;x2&#39;</span>)] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.matrix</span>()
y &lt;-<span class="st"> </span>train_df[[<span class="st">&#39;class&#39;</span>]] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.numeric</span>()

d &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, N)
D &lt;-<span class="st"> </span>(y <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(y)) <span class="op">*</span><span class="st"> </span>(X <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(X))</code></pre></div>
<p>여기에서 행렬 <span class="math inline">\(\mathbf{D}\)</span>의 determinant 값은 0으로, <span class="citation">Goldfarb and Idnani (<a href="#ref-goldfarb1983numerically">1983</a>)</span> 가 가정하는 symmetric positive definite matrix 조건에 위배되어 <code>solve.QP</code> 함수 실행 시 오류가 발생한다. 이를 방지하기 위해 아래 예에서는 <code>Matrix</code> 패키지의 <code>nearPD</code>함수를 이용하여 행렬 <span class="math inline">\(\mathbf{D}\)</span>와 근사한 symmetric positive definite matrix를 아래와 같이 찾는다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_pd &lt;-<span class="st"> </span>Matrix<span class="op">::</span><span class="kw">nearPD</span>(D, <span class="dt">doSym =</span> T)<span class="op">$</span>mat <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.matrix</span>()</code></pre></div>
<p>식 <a href="svm.html#eq:quadprog">(2.4)</a>의 제약식은 모두 inequality 형태로, 식 <a href="svm.html#eq:linear-svm-dual">(2.3)</a>의 equality constraint <span class="math inline">\(\sum_{i = 1}^{N} \alpha_i y_i = 0\)</span>를 표현하기 위해서 두 개의 제약식 <span class="math inline">\(\sum_{i = 1}^{N} \alpha_i y_i \ge 0\)</span>와 <span class="math inline">\(\sum_{i = 1}^{N} - \alpha_i y_i \ge 0\)</span>를 생성한다.</p>
<span class="math display">\[\begin{equation*}
\mathbf{A}^\top = \left[ 
\begin{array}{c c c c}
y_1 &amp; y_2 &amp; \cdots &amp; y_N\\
-y_1 &amp; -y_2 &amp; \cdots &amp; -y_N\\
1 &amp; 0 &amp; \cdots &amp; 0\\
0 &amp; 1 &amp; \cdots &amp; 0\\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
0 &amp; 0 &amp; \cdots &amp; 1
\end{array}
\right],
\mathbf{b}_0 = \left[ \begin{array}{c}
0 \\ 0 \\ 0 \\ 0 \\ \cdots \\ 0
\end{array}
\right]
\end{equation*}\]</span>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">A &lt;-<span class="st"> </span><span class="kw">cbind</span>(
  y,
  <span class="op">-</span>y,
  <span class="kw">diag</span>(N)
)
b_zero &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">+</span><span class="st"> </span>N)</code></pre></div>
<p>이제 위에서 구한 행렬과 벡터들을 <code>solve.QP</code> 함수에 입력하여 최적해를 구한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span>quadprog<span class="op">::</span><span class="kw">solve.QP</span>(D_pd, d, A, b_zero)
alpha_sol &lt;-<span class="st"> </span>res<span class="op">$</span>solution
obj_val &lt;-<span class="st"> </span><span class="op">-</span>res<span class="op">$</span>value</code></pre></div>
<table>
<caption><span id="tab:svm-separable-alpha">Table 2.2: </span>이차계획문제의 최적해</caption>
<thead>
<tr class="header">
<th align="center">variable</th>
<th align="center">solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">alpha_1</td>
<td align="center">0.2234</td>
</tr>
<tr class="even">
<td align="center">alpha_2</td>
<td align="center">0.0000</td>
</tr>
<tr class="odd">
<td align="center">alpha_3</td>
<td align="center">0.0000</td>
</tr>
<tr class="even">
<td align="center">alpha_4</td>
<td align="center">0.0000</td>
</tr>
<tr class="odd">
<td align="center">alpha_5</td>
<td align="center">0.2228</td>
</tr>
<tr class="even">
<td align="center">alpha_6</td>
<td align="center">0.0000</td>
</tr>
<tr class="odd">
<td align="center">alpha_7</td>
<td align="center">0.2210</td>
</tr>
<tr class="even">
<td align="center">alpha_8</td>
<td align="center">0.0000</td>
</tr>
<tr class="odd">
<td align="center">alpha_9</td>
<td align="center">0.2216</td>
</tr>
</tbody>
</table>
<p>표 <a href="svm.html#tab:svm-separable-alpha">2.2</a>의 결과는 교재<span class="citation">(전치혁 <a href="#ref-jun2012datamining">2012</a>)</span>에 나타난 최적해와는 다소 차이가 있으나, 결과적으로 목적함수값은 0.4444로 동일하다.</p>
<p>위의 과정으로 최적해 <span class="math inline">\(\alpha_{i}^{*}\)</span>를 구한 뒤, 아래와 같이 분리 하이퍼플레인의 계수를 결정할 수 있다.</p>
<span class="math display">\[\begin{eqnarray*}
\mathbf{w} &amp;=&amp; \sum_{i = 1}^{N} \alpha_{i}^{*} y_{i} \mathbf{x}_{i}\\
b &amp;=&amp; \sum_{i: \alpha_{i}^{*} &gt; 0} \frac{1 - y_{i} \mathbf{w}^{\top} \mathbf{x}_{i}}{y_{i}} \left/ \sum_{i: \alpha_{i}^{*} &gt; 0} 1 \right. 
\end{eqnarray*}\]</span>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">w &lt;-<span class="st"> </span><span class="kw">colSums</span>(alpha_sol <span class="op">*</span><span class="st"> </span>y <span class="op">*</span><span class="st"> </span>X)

sv_ind &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">round</span>(alpha_sol, <span class="dt">digits =</span> <span class="dv">4</span>) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)
b &lt;-<span class="st"> </span><span class="kw">mean</span>((<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>y[sv_ind] <span class="op">*</span><span class="st"> </span>(X[sv_ind, ] <span class="op">%*%</span><span class="st"> </span>w)) <span class="op">/</span><span class="st"> </span>y[sv_ind])</code></pre></div>
<p>위 결과 분리 하이퍼플레인은 교재와 동일하게 얻어진다.</p>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-jun2012datamining">
<p>전치혁. 2012. <em>데이터마이닝 기법과 응용</em>. 한나래출판사.</p>
</div>
<div id="ref-goldfarb1983numerically">
<p>Goldfarb, Donald, and Ashok Idnani. 1983. “A Numerically Stable Dual Method for Solving Strictly Convex Quadratic Programs.” <em>Mathematical Programming</em> 27 (1). Springer: 1–33.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="tree-based-method.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="references.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
